@page "/minesweeper"
@using Microsoft.AspNetCore.Components.Web
@using System.Timers
@implements IDisposable

<div class="container">

    <div class="game-controls">
        <label for="boardSize">Select Board Size: </label>
        <select id="boardSize" @onchange="ChangeBoardSize">
            <option value="8x8">8x8</option>
            <option value="16x16">16x16</option>
            <option value="30x16">30x16</option>
        </select>
        
    </div>

    <div class="game-section" >

        <div class="game-status">
            <span>Time: @elapsedTime seconds</span>
            <button @onclick="InitializeGame">Reset Game</button>
        </div>

        @if (cells != null)
        {
            <div class="game-board" tabindex="0" >
                @for (int row = 0; row < Rows; row++)
                {
                    <div class="board-row" >
                        @for (int col = 0; col < Columns; col++)
                        {
                            var currentRow = row;
                            var currentCol = col;
                            <button @onclick="() => CellClicked(currentRow, currentCol)" 
                                    @oncontextmenu="(e) => HandleRightClick(e, currentRow, currentCol)"
                                    class="board-cell" disabled="@cells[row, col].IsRevealed" @oncontextmenu:preventDefault="true">
                                @GetCellContent(row, col)
                            </button>
                        }
                    </div>
                }
            </div>
        }
    </div>

    <div class="best-times">
        <h3>Best Times</h3>
        <ul>
            @foreach (var bestTime in bestTimes)
            {
                <li>@bestTime.Size - @bestTime.Time: @bestTime.Seconds seconds on @bestTime.Date</li>
            }
        </ul>
    </div>
</div>


@code {
    private int Rows = 8;
    private int Columns = 8;
    private int Mines = 10;
    private Cell[,] cells;
    private bool GameOver = false;
    private bool FirstClick = true;
    private System.Timers.Timer gameTimer;
    private double elapsedTime = 0;
    private List<BestTime> bestTimes = new();

    private IJSObjectReference module;
    private IJSObjectReference localStorageModule;

    [Inject] private IJSRuntime jsRuntime { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadLocalStorage();
        await LoadBestTimes();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await jsRuntime.InvokeAsync<IJSObjectReference>("import", "./localStorage.js");
            await jsRuntime.InvokeVoidAsync("addKeyListener", DotNetObjectReference.Create(this));
            InitializeGame();
        }
    }

    private async Task LoadLocalStorage()
    {
        localStorageModule = await jsRuntime.InvokeAsync<IJSObjectReference>("import", "./localStorage.js");
    }
    [JSInvokable]
    public void ResetGame()
    {
        InitializeGame();
    }
    private async void HandleRightClick(MouseEventArgs e, int row, int col)
    {
        ToggleFlag(row, col);
    }

    private void ToggleFlag(int row, int col)
    {
        if (!cells[row, col].IsRevealed)
        {
            cells[row, col].IsFlagged = !cells[row, col].IsFlagged;
        }
        StateHasChanged();
    }

    private void SaveBestTime()
    {
        string size = $"{Rows}x{Columns}";
        bestTimes.Add(new BestTime
            {
                Size = size,
                Seconds = elapsedTime,
                Date = DateTime.Now
            });
        var jsonBestTimes = System.Text.Json.JsonSerializer.Serialize(bestTimes);
        localStorageModule.InvokeVoidAsync("setItem", "BestTimes", jsonBestTimes);
    }

    private async Task LoadBestTimes()
    {
        var jsonBestTimes = await localStorageModule.InvokeAsync<string>("getItem", "BestTimes");
        if (!string.IsNullOrEmpty(jsonBestTimes))
        {
            bestTimes = System.Text.Json.JsonSerializer.Deserialize<List<BestTime>>(jsonBestTimes);
        }
    }

    public void Dispose()
    {
        gameTimer?.Dispose();
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "r" || e.Key == "R")
        {
            InitializeGame();
        }
    }

    private void UpdateElapsedTime(object sender, ElapsedEventArgs e)
    {
        elapsedTime++;
        InvokeAsync(StateHasChanged);
    }

    private void ChangeBoardSize(ChangeEventArgs e)
    {
        var selectedSize = e.Value.ToString();
        switch (selectedSize)
        {
            case "8x8":
                Rows = 8;
                Columns = 8;
                Mines = 10;
                break;
            case "16x16":
                Rows = 16;
                Columns = 16;
                Mines = 40;
                break;
            case "30x16":
                Rows = 16;
                Columns = 30;
                Mines = 99;
                break;
        }
        InitializeGame();
    }

    private void InitializeGame()
    {
        cells = new Cell[Rows, Columns];
        for (int row = 0; row < Rows; row++)
        {
            for (int col = 0; col < Columns; col++)
            {
                cells[row, col] = new Cell();
            }
        }
        PlaceMines();
        CalculateAdjacentMines();
        GameOver = false;
        FirstClick = true;
        elapsedTime = 0;
        gameTimer?.Stop();
        gameTimer = new System.Timers.Timer(1000);
        gameTimer.Elapsed += UpdateElapsedTime;
        StateHasChanged();  // Ensure the board remains static after reset
    }

    private void PlaceMines()
    {
        var random = new Random();
        int minesPlaced = 0;
        while (minesPlaced < Mines)
        {
            int row = random.Next(Rows);
            int col = random.Next(Columns);
            if (!cells[row, col].IsMine)
            {
                cells[row, col].IsMine = true;
                minesPlaced++;
            }
        }
    }

    private void CalculateAdjacentMines()
    {
        for (int row = 0; row < Rows; row++)
        {
            for (int col = 0; col < Columns; col++)
            {
                if (!cells[row, col].IsMine)
                {
                    int adjacentMines = 0;
                    for (int r = row - 1; r <= row + 1; r++)
                    {
                        for (int c = col - 1; c <= col + 1; c++)
                        {
                            if (r >= 0 && r < Rows && c >= 0 && c < Columns && cells[r, c].IsMine)
                            {
                                adjacentMines++;
                            }
                        }
                    }
                    cells[row, col].AdjacentMines = adjacentMines;
                }
            }
        }
    }

    private void CellClicked(int row, int col)
    {
        if (GameOver || cells[row, col].IsFlagged)
        {
            return;
        }
        if (FirstClick)
        {
            gameTimer.Start();  // Start the timer at the beginning of the game

            FirstClick = false;
            if (cells[row, col].IsMine)
            {
                RepositionMine(row, col);
            }
        }
        if (cells[row, col].IsMine)
        {
            GameOver = true;
            RevealAllMines();
            gameTimer.Stop();
        }
        else
        {
            RevealCell(row, col);
            if (CheckWinCondition())
            {
                GameOver = true;
                gameTimer.Stop();
                SaveBestTime();
            }
        }
    }

    private void RepositionMine(int row, int col)
    {
        cells[row, col].IsMine = false;
        PlaceMines();
        CalculateAdjacentMines();
    }

    private void RevealCell(int row, int col)
    {
        if (cells[row, col].IsRevealed || cells[row, col].IsFlagged)
        {
            return;
        }
        cells[row, col].IsRevealed = true;
        if (cells[row, col].AdjacentMines == 0)
        {
            for (int r = row - 1; r <= row + 1; r++)
            {
                for (int c = col - 1; c <= col + 1; c++)
                {
                    if (r >= 0 && r < Rows && c >= 0 && c < Columns)
                    {
                        RevealCell(r, c);
                    }
                }
            }
        }
        StateHasChanged();
    }

    private void RevealAllMines()
    {
        for (int row = 0; row < Rows; row++)
        {
            for (int col = 0; col < Columns; col++)
            {
                if (cells[row, col].IsMine)
                {
                    cells[row, col].IsRevealed = true;
                }
            }
        }
    }

    private bool CheckWinCondition()
    {
        for (int row = 0; row < Rows; row++)
        {
            for (int col = 0; col < Columns; col++)
            {
                if (!cells[row, col].IsMine && !cells[row, col].IsRevealed)
                {
                    return false;
                }
            }
        }
        return true;
    }

    private string GetCellContent(int row, int col)
    {
        if (cells[row, col].IsFlagged)
        {
            return "🚩";
        }
        if (!cells[row, col].IsRevealed)
        {
            return " ";
        }
        if (cells[row, col].IsMine)
        {
            return "💣";
        }
        return cells[row, col].AdjacentMines > 0 ? cells[row, col].AdjacentMines.ToString() : string.Empty;
    }

    private class Cell
    {
        public bool IsMine { get; set; }
        public bool IsRevealed { get; set; }
        public bool IsFlagged { get; set; }
        public int AdjacentMines { get; set; }
    }

    private class BestTime
    {
        public string Size { get; set; }
        public double Seconds { get; set; }
        public DateTime Date { get; set; }
        public string Time => Date.ToString("HH:mm:ss");
    }
}

<style>
    .container {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 20px;
    }

    .game-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        min-width: 300px;
    }

    .game-status {
        text-align: center;
    }

    .game-board {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .board-row {
        display: flex;
    }

    .board-cell {
        width: 30px;
        height: 30px;
        margin: 1px;
        padding: 0;
        background-color: #eee;
        border: 1px solid #000;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        line-height: 30px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }

        .board-cell:disabled {
            background-color: #ddd;
            cursor: default;
        }

        .board-cell.flagged {
            background-color: #f00;
            color: #fff;
        }

        .board-cell.mine {
            background-color: #000;
            color: #fff;
        }
    .best-times {
        min-width: 200px;
        flex: 1;
    }

        .best-times h3 {
            margin-top: 0;
        }
</style>